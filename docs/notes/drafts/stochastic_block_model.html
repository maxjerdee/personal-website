<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.555">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2025-07-15">
<meta name="description" content="Review of the modularity and stochastic block model, and their use to find latent group structure in networks">

<title>Max Jerdee - Network groups</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<link href="../../assets/images/icon.svg" rel="icon" type="image/svg+xml">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../../site_libs/bootstrap/bootstrap-dark.min.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-SY1YC6MMLM"></script>

<script type="text/javascript">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-SY1YC6MMLM', { 'anonymize_ip': true});
</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Max Jerdee</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../research.html"> 
<span class="menu-text">Research</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../papers.html"> 
<span class="menu-text">Papers</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../code.html"> 
<span class="menu-text">Code</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../demos.html"> 
<span class="menu-text">Demos</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../notes.html"> 
<span class="menu-text">Notes</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../cv.html"> 
<span class="menu-text">CV</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
          <div class="quarto-navbar-tools">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#sec:SBM" id="toc-sec:SBM" class="nav-link active" data-scroll-target="#sec\:SBM">Stochastic block model</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Network groups</h1>
  <div class="quarto-categories">
    <div class="quarto-category">Network science</div>
  </div>
  </div>

<div>
  <div class="description">
    Review of the modularity and stochastic block model, and their use to find latent group structure in networks
  </div>
</div>


<div class="quarto-title-meta">

    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">July 15, 2025</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<section id="sec:SBM" class="level2">
<h2 class="anchored" data-anchor-id="sec:SBM">Stochastic block model</h2>
<p>In the previous section, we extended the &nbsp;random graph to the general configuration model to detect and quantify statistically significant variations in node degrees. In this section, we introduce the stochastic block model (SBM), which similarly models group structures such as those discussed in Section&nbsp;<a href="#sec:group-structure" data-reference-type="ref" data-reference="sec:group-structure">[sec:group-structure]</a>.</p>
<p>Groups in networks are often characterized as communities of tightly connected nodes. In the examples shown in Figure&nbsp;<a href="#fig:community-examples" data-reference-type="ref" data-reference="fig:community-examples">[fig:community-examples]</a>a-c, the groups are assortative as indicated by the high number of edges&nbsp;<span class="math inline">\(m_{\text{in}}\)</span> between nodes of the same group. To count these intra-group edges, we index the groups by&nbsp;<span class="math inline">\(r = 1,...,q\)</span> and represent group assignments as an <span class="math inline">\(n\)</span>-vector of integers&nbsp;<span class="math inline">\(\boldsymbol{b}\)</span>, where each node&nbsp;<span class="math inline">\(i\)</span> belongs to group&nbsp;<span class="math inline">\(b_i \in \{1,...,q\}\)</span>. In this notation, the number of edges inside groups is</p>
<div style="overflow-x:auto;overflow-y:hidden;">
<p><span class="math display">\[\begin{aligned}
    m_{\text{in}} = \frac{1}{2} \sum_{i,j=1}^n A_{ij} \delta_{b_ib_j},\end{aligned}\]</span></p>
</div>
<p>where the Kronecker delta&nbsp;<span class="math inline">\(\delta_{b_ib_j}\)</span> restricts the sum to nodes&nbsp;<span class="math inline">\(i\)</span> and&nbsp;<span class="math inline">\(j\)</span> in the same group. While a large number of edges&nbsp;<span class="math inline">\(m_{\text{in}}\)</span> within the groups suggests a strong group structure, it is important to contextualize this count. Even if there is no assortative preference, randomly placed edges can fall within groups and contribute to&nbsp;<span class="math inline">\(m_{\text{in}}\)</span>.</p>
<p>To establish a baseline for&nbsp;<span class="math inline">\(m_{\text{in}}\)</span>, we use the microcanonical configuration model Eq.&nbsp;<a href="#eq:P-A-given-k" data-reference-type="eqref" data-reference="eq:P-A-given-k">[eq:P-A-given-k]</a> as a null hypothesis. This generates alternative networks that match the observed node degrees but lack inherent group structure. Under this randomization, the expected number of edges between any two nodes&nbsp;<span class="math inline">\(i\)</span> and&nbsp;<span class="math inline">\(j\)</span> is</p>
<div style="overflow-x:auto;overflow-y:hidden;">
<p><span class="math display">\[\begin{aligned}
    \mathbf{E} A_{ij} = \frac{k_i k_j}{2m}.\end{aligned}\]</span></p>
</div>
<p>We thus expect a total number of intra-group edges</p>
<div style="overflow-x:auto;overflow-y:hidden;">
<p><span class="math display">\[\begin{aligned}
    \langle m_{\text{in}} \rangle_{\text{config}} &amp;= \frac{1}{2}\sum_{ij} \frac{k_ik_j}{2m} \delta_{b_ib_j}.\end{aligned}\]</span></p>
</div>
<p>To demonstrate that the groups are meaningfully assortative, we then check if the count&nbsp;<span class="math inline">\(m_{\text{in}}\)</span> observed in the network is surprising relative to this expectation.</p>
<p>A measure known as the <em>modularity</em>&nbsp;<span class="citation" data-cites="Newman06b">(<a href="#ref-Newman06b" role="doc-biblioref">Newman 2006</a>)</span> quantifies and normalizes this difference as</p>
<div style="overflow-x:auto;overflow-y:hidden;">
<p><span id="eq-modularity"><span class="math display">\[\begin{aligned}
    Q(A,\boldsymbol{b}) &amp;= \frac{1}{m}\left(m_{\text{in}} - \langle m_{\text{in}} \rangle_{\text{config}}\right) \nonumber \\
    &amp;= \frac{1}{2m}\sum_{ij} \left(A_{ij} - \frac{k_ik_j}{2m}\right) \delta_{b_ib_j}. \end{aligned} \tag{1}\]</span></span></p>
</div>
<p>This definition ensures that the expected modularity of a partition is 0, and a positive value indicates that the network is more assortative, or <em>modular</em>, than we would expect.</p>
<p>Within the significance testing framework, we can also compute the p-value that the configuration model could generate a network as assortative as the observed case. <a href="#fig-modularity-large" class="quarto-xref">Figure&nbsp;1</a> shows an example of this test on the network of Division IA college football matches considered in the previous section. Here we can calculate the modularity of the network across the&nbsp;<span class="math inline">\(q = 12\)</span> conferences, represented by node colors in <a href="#fig-modularity-large" class="quarto-xref">Figure&nbsp;1</a>a. Across the season, <span class="math inline">\(m_{\text{in}} = 397\)</span> of the <span class="math inline">\(m = 616\)</span> matches are played between teams in the same conference (highlighted in green), leading to a network modularity of&nbsp;<span class="math inline">\(Q = 0.555\)</span>. <a href="#fig-modularity-large" class="quarto-xref">Figure&nbsp;1</a>b compares the modularity along this partition in the real network to that in 10,000 alternative networks drawn from the configuration model. Across these cases the largest modularity obtained is&nbsp;<span class="math inline">\(Q = 0.041\)</span>, indicating that there is a very statistically significant preference for teams to play within their own conference.</p>
<div id="fig-modularity-large" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-modularity-large-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="../../assets/images/notes/stochastic_block_model/modularity-large.svg" class="img-fluid figure-img" style="width:7.05633in">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-modularity-large-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;1: (a) Football match network with edges within groups highlighted in green and edges between groups in red. (b) Modularity of the conference partition of the football match network (vertical dashed line) compared to 10,000 alternative networks with the same degree sequence sampled from the configuration model.
</figcaption>
</figure>
</div>
<p>In an unsupervised setting, where the group structure of the network is unknown, the modularity is often used not only to measure behavior but also to identify groups. In this approach, a "good" group structure is defined as one with high modularity, where groups contain significantly more internal edges than expected by chance. Thus, for a given network&nbsp;<span class="math inline">\(\boldsymbol{A}\)</span>, the best-fit group structure is the optimum</p>
<div style="overflow-x:auto;overflow-y:hidden;">
<p><span class="math display">\[\begin{aligned}
    \boldsymbol{b}^* = \argmax_{\boldsymbol{b}} Q(\boldsymbol{A},\boldsymbol{b}),\end{aligned}\]</span></p>
</div>
<p>where <span class="math inline">\(\boldsymbol{b}^*\)</span> is found using one of several <em>modularity maximization</em> methods. Some commonly used algorithms are discussed in Appendix&nbsp;<a href="#app:algorithms" data-reference-type="ref" data-reference="app:algorithms">[app:algorithms]</a>.</p>
<p>Applying this strategy to the football match network, we can find a partition of the teams into 11 groups with modularity&nbsp;<span class="math inline">\(Q = 0.601\)</span>. Remarkably, this partition closely resembles the "true" conference group structure. Using the information-theoretic similarity measure defined in Chapter&nbsp;<a href="#chp:information" data-reference-type="ref" data-reference="chp:information">[chp:information]</a>, the found partition scores a 0.865 out of 1. From the network alone, we can thus nearly recover the original conferences. Encouraged by this result, we can apply this method to help uncover groups of nodes that meaningfully influence the structure of the network, even when such groups are initially unknown.</p>
<p>While this modularity maximization approach has been widely used to great effect in network science&nbsp;<span class="citation" data-cites="Barber07 Boccaletti07 GDC10">(<a href="#ref-Barber07" role="doc-biblioref">Barber 2007</a>; <a href="#ref-Boccaletti07" role="doc-biblioref">Boccaletti et al. 2007</a>; <a href="#ref-GDC10" role="doc-biblioref">Good, Montjoye, and Clauset 2010</a>)</span>, it has certain limitations. One major issue is overfitting. Consider a graph that inherently lacks a group structure, such as those generated by &nbsp;or configuration models. In such cases the appropriate "partition" of the nodes places them into one large group,&nbsp;<span class="math inline">\(\boldsymbol{b} = (1,...,1)\)</span>. From the definition of the modularity, this all-in-one grouping has&nbsp;<span class="math inline">\(Q = 0\)</span> for any network&nbsp;<span class="math inline">\(\boldsymbol{A}\)</span>. However, when optimizing the modularity, it is typically possible to find some other partition of the nodes into more than one group that is at least slightly assortative,&nbsp;<span class="math inline">\(Q &gt; 0\)</span>, merely due to random graph fluctuations. Modularity maximization will therefore prefer this over-fitted partition over the true single group.</p>
<p><a href="#fig-modularity-small" class="quarto-xref">Figure&nbsp;2</a> exemplifies this issue by illustrating the network of matches played within only the Big Ten college football conference in 2022. This network presumably lacks group structure, given that it represents a single conference. Yet, the modularity is maximized at positive&nbsp;<span class="math inline">\(Q = 0.156\)</span> by dividing the teams into two groups, as shown in <a href="#fig-modularity-small" class="quarto-xref">Figure&nbsp;2</a>a. In <a href="#fig-modularity-small" class="quarto-xref">Figure&nbsp;2</a>b we again consider this modularity in the context of 10,000 alternative networks that share the same degree sequence. In this case, the observed modularity is not clearly separated from what the configuration model predicts, but still yields a p-value <span class="math inline">\(P = 0.01\)</span>. In isolation, this might imply a statistically significant assortative pattern. However, given that this grouping was selected among&nbsp;<span class="math inline">\(2^{n - 1} - 1 = 8191\)</span> possible two-group partitions, is it not unexpected that one might exhibit such a low p-value. Since the modularity alone can never return a null result, modularity maximization must be combined with such significance testing that is often challenging to interpret.</p>
<div id="fig-modularity-small" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-modularity-small-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="../../assets/images/notes/stochastic_block_model/modularity-small.svg" class="img-fluid figure-img" style="width:7.04133in">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-modularity-small-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;2: (a) Network of football matches within only the Big Ten conference. The teams are partitioned into two groups to maximize modularity. (b) The modularity along the optimized partition compared that in 10,000 networks with the same degree sequence sampled from the configuration model.
</figcaption>
</figure>
</div>
<p>Even when no true assortative pattern is present, modularity maximization will overfit and report some slightly assortative partition. In cases where the actual group structure is <em>disassortative</em>, such as the bipartite network of Figure&nbsp;<a href="#fig:community-examples" data-reference-type="ref" data-reference="fig:community-examples">[fig:community-examples]</a>d, modularity maximization will also fail to identify the true groups. This is because disassortative groups do not align with modularity’s fundamentally assortative definition of a community. To successfully identify such groups, we must broaden our definition to include these cases, or even more complex structural patterns like mixtures of assortative and disassortative groups.</p>
<p>The root of these issues lies in the fact that modularity maximization is not a generative model, unlike the &nbsp;or configuration models described earlier. While the partition that maximizes the modularity is useful for describing and summarizing assortative network structures, it does not provide a mechanism for their formation. This precludes us from employing our usual Bayesian inference tools to prevent overfitting or from using the modularity to make predictions.</p>
<p>While some efforts have been made to directly convert the modularity objective function into a generative model&nbsp;<span class="citation" data-cites="PK23">(<a href="#ref-PK23" role="doc-biblioref">Peixoto and Kirkley 2023</a>)</span>, in this thesis we instead consider <em>stochastic block models</em> (SBMs). These models come in a variety of different flavors&nbsp;<span class="citation" data-cites="KN11a Peixoto14a YL2020">(<a href="#ref-KN11a" role="doc-biblioref">Karrer and Newman 2011</a>; <a href="#ref-Peixoto14a" role="doc-biblioref">Peixoto 2014</a>; <a href="#ref-YL2020" role="doc-biblioref">Yen and Larremore 2020</a>)</span>, some of which we introduce in Chapter&nbsp;<a href="#chp:group-structure" data-reference-type="ref" data-reference="chp:group-structure">[chp:group-structure]</a>. They provide the flexibility to model a wide range of possible group structures and can be directly compared against the other generative models we have considered.</p>
<p>The traditional stochastic block model is defined by the assumption that the probability two nodes&nbsp;<span class="math inline">\(i\)</span> and <span class="math inline">\(j\)</span> are connected depends only on their group identities&nbsp;<span class="math inline">\(b_i\)</span> and <span class="math inline">\(b_j\)</span>. Some pairs of groups may be more likely to be connected than others, but all nodes within the same group share the same structural role: they are identically and independently likely to be connected to nodes in other groups. These probabilities across groups form a symmetric&nbsp;<span class="math inline">\(q \times q\)</span> <em>weight matrix</em>&nbsp;<span class="math inline">\(\boldsymbol{\omega}\)</span>, where&nbsp;<span class="math inline">\(\omega_{rs}\)</span> is the expected number of edges between each node in group&nbsp;<span class="math inline">\(r\)</span> and each node in group&nbsp;<span class="math inline">\(s\)</span>. This framework effectively defines what we mean by groups: node labels that influence the pattern of connections. This pattern can be quite generic as we do not assume the groups are defined by a globally assortative or disassortative preference.</p>
<p>For each pair of groups&nbsp;<span class="math inline">\(r\)</span> and&nbsp;<span class="math inline">\(s\)</span>, the weight matrix entry&nbsp;<span class="math inline">\(\omega_{rs}\)</span> plays the same role as the overall density&nbsp;<span class="math inline">\(\rho\)</span> in the &nbsp;multigraph model Eq.&nbsp;<a href="#eq:ER-multigraph-canonical" data-reference-type="eqref" data-reference="eq:ER-multigraph-canonical">[eq:ER-multigraph-canonical]</a>. Each edge count&nbsp;<span class="math inline">\(A_{ij}\)</span> is modeled as a Poisson distribution with expectation&nbsp;<span class="math inline">\(\omega_{b_ib_j}\)</span>. Consequently, the usual SBM models the interior of each group&nbsp;<span class="math inline">\(r\)</span> as a random multigraph with density&nbsp;<span class="math inline">\(\omega_{rr}\)</span> and assumes connections between groups occur independently and identically.</p>
<p>By building the model in this way, the SBM becomes a nested model that includes an &nbsp;random graph as the special case where all nodes are assigned to a single group,&nbsp;<span class="math inline">\(\boldsymbol{b} = (1,...,1)\)</span>. Just as the general configuration model, this nested structure allows us to directly compare the SBM against the &nbsp;model it extends. Collecting these assumptions, the likelihood that a network is generated by a group structure&nbsp;<span class="math inline">\(\boldsymbol{b}\)</span> and weights&nbsp;<span class="math inline">\(\boldsymbol{\omega}\)</span> in the SBM is then</p>
<div style="overflow-x:auto;overflow-y:hidden;">
<p><span id="eq-P-A-given-omega-b"><span class="math display">\[\begin{aligned}
    P(\boldsymbol{A}|\boldsymbol{\omega},\boldsymbol{b}) &amp;= \prod_{i &lt; j}\frac{\omega_{b_ib_j}^{A_{ij}}e^{-\omega_{b_ib_j}}}{A_{ij}!}  \prod_{i=1}^n \frac{(\omega_{b_ib_i}/2)^{A_{ii}/2}e^{-\omega_{b_ib_i}/2}}{(A_{ii}/2)!}. \end{aligned} \tag{2}\]</span></span></p>
</div>
<p>We can condense this expression by introducing some useful notation. We denote the number of nodes in group&nbsp;<span class="math inline">\(r\)</span> as</p>
<div style="overflow-x:auto;overflow-y:hidden;">
<p><span class="math display">\[\begin{aligned}
    n_r = \sum_{i=1}^n \delta_{b_ir},\end{aligned}\]</span></p>
</div>
<p>forming the <span class="math inline">\(q\)</span>-vector of integers&nbsp;<span class="math inline">\(\boldsymbol{n}\)</span>, and count the number of edges that run between groups&nbsp;<span class="math inline">\(r, s = 1,...,q\)</span> as</p>
<div style="overflow-x:auto;overflow-y:hidden;">
<p><span id="eq-M-edge-count-matrix"><span class="math display">\[\begin{aligned}
    M_{rs} = \sum_{i,j=1}^n A_{ij} \delta_{b_ir}\delta_{b_js}, \end{aligned} \tag{3}\]</span></span></p>
</div>
<p>entries of the symmetric&nbsp;<span class="math inline">\(q \times q\)</span> <em>edge count matrix</em>&nbsp;<span class="math inline">\(\boldsymbol{M}\)</span>. Analogous to the adjacency matrix, the diagonal elements of this edge count matrix&nbsp;<span class="math inline">\(M_{rr}\)</span> are twice the number of edges that run internally between nodes in group&nbsp;<span class="math inline">\(r\)</span>. This convention ensures that the row sum of the edge count matrix&nbsp;<span class="math inline">\(\boldsymbol{m}\)</span> has entries</p>
<div style="overflow-x:auto;overflow-y:hidden;">
<p><span class="math display">\[\begin{aligned}
    m_r = \sum_{s = 1}^q M_{rs} = \sum_{i=1}^n k_i \delta_{b_ir}\end{aligned}\]</span></p>
</div>
<p>equal to the total degree of the nodes in each group. With this notation we can then collect the likelihood terms as</p>
<div style="overflow-x:auto;overflow-y:hidden;">
<p><span class="math display">\[\begin{aligned}
    P(\boldsymbol{A}|\boldsymbol{\omega},\boldsymbol{b}) &amp;= \frac{1}{\prod_{i&lt;j}A_{ij}!\prod_i A_{ii}!!} \prod_{r&lt;s}\omega_{rs}^{M_{rs}} e^{-n_rn_s \omega_{rs}}\prod_{r=1}^q \omega_{rr}^{M_{rr}/2} e^{-n_r^2 \omega_{rr}/2}.\end{aligned}\]</span></p>
</div>
<p>At this stage, we may be tempted to perform a maximum-likelihood estimate and find the choice of weights&nbsp;<span class="math inline">\(\boldsymbol{\omega}\)</span> and partition&nbsp;<span class="math inline">\(\boldsymbol{b}\)</span> most likely to produce the observed network. Unfortunately this approach has serious issues. Consider the group partition&nbsp;<span class="math inline">\(\boldsymbol{b} = (1,...,n)\)</span> that places each node in its own group and the weight matrix&nbsp;<span class="math inline">\(\boldsymbol{\omega} = \boldsymbol{A}\)</span> between the now&nbsp;<span class="math inline">\(n\)</span> groups. Although this choice of parameters then has a very high model likelihood <a href="#eq-P-A-given-omega-b" class="quarto-xref">Eq.&nbsp;2</a>, as each edge&nbsp;<span class="math inline">\(A_{ij}\)</span> is drawn from a Poisson distribution of the same mean&nbsp;<span class="math inline">\(A_{ij}\)</span>, the overall model is woefully over-parametrized. The weight matrix alone contains as many parameters as the data&nbsp;<span class="math inline">\(\boldsymbol{A}\)</span> itself and overfits the network.</p>
<p>Our familiar solution to this problem is to carefully introduce priors over the parameters&nbsp;<span class="math inline">\(\boldsymbol{\omega}\)</span> and&nbsp;<span class="math inline">\(\boldsymbol{b}\)</span> that reflect what we expect "typical" weight and group structures to look like. As in the general configuration model, the choices of these priors matter considerably in realistic network applications. For example in Section&nbsp;<a href="#sec:assortative-SBM" data-reference-type="ref" data-reference="sec:assortative-SBM">[sec:assortative-SBM]</a> we discuss how the choice of weight matrix prior&nbsp;<span class="math inline">\(P(\boldsymbol{\omega})\)</span> drastically influences model behavior. In this introduction, however, we will review the choices most often made for the traditional SBM.</p>
<p>Over possible group structures&nbsp;<span class="math inline">\(\boldsymbol{b}\)</span> we use a prior</p>
<div style="overflow-x:auto;overflow-y:hidden;">
<p><span id="eq-P-b"><span class="math display">\[\begin{aligned}
    P(\boldsymbol{b}) &amp;= P(\boldsymbol{b}|\boldsymbol{n})P(\boldsymbol{n}|q)P(q) \nonumber \\
    &amp;= \frac{\prod_r n_r!}{n!} \binom{n-1}{q-1}^{-1}\frac{1}{n} \end{aligned} \tag{4}\]</span></span></p>
</div>
<p>which is uniform over the number of groups&nbsp;<span class="math inline">\(q\)</span> ranging from&nbsp;<span class="math inline">\(1\)</span> to&nbsp;<span class="math inline">\(n\)</span>, over the possible node count vectors&nbsp;<span class="math inline">\(\boldsymbol{n}\)</span> as positive integer vectors of length&nbsp;<span class="math inline">\(q\)</span> that sum to&nbsp;<span class="math inline">\(n\)</span>, and over the possible partitions&nbsp;<span class="math inline">\(\boldsymbol{b}\)</span> that satisfy the node counts&nbsp;<span class="math inline">\(\boldsymbol{n}\)</span>. This structure of the prior ensures that <em>a priori</em> we have no preference for any particular number of communities&nbsp;<span class="math inline">\(q\)</span>. For instance there is prior probability&nbsp;<span class="math inline">\(P(q = 1) = 1/n\)</span> that all nodes belong in one group. This case recovers the &nbsp;random graph, the possibility of no community structure. If we had instead used a prior that is simply uniform over all possible&nbsp;<span class="math inline">\(n\)</span>-vectors of integers from 1 to <span class="math inline">\(n\)</span>, the prior would heavily weigh a large number of communities, as most such labelings have a number of distinct groups&nbsp;<span class="math inline">\(q \sim n\)</span>, and&nbsp;<span class="math inline">\(q = 1\)</span> would be effectively excluded from the prior distribution.</p>
<p>For the weight matrix&nbsp;<span class="math inline">\(\boldsymbol{\omega}\)</span>, we traditionally use i.i.d. exponential priors of mean&nbsp;<span class="math inline">\(\rho &gt; 0\)</span> on the upper triangular entries&nbsp;<span class="math inline">\(\omega_{rs}\)</span> where&nbsp;<span class="math inline">\(r \leq s\)</span>. To generate a symmetric matrix, we then set the entries below the diagonal to those above it as <span class="math inline">\(\omega_{sr} = \omega_{rs}\)</span>. This gives the prior over symmetric weight matrices</p>
<div style="overflow-x:auto;overflow-y:hidden;">
<p><span id="eq-P-omega-given-rho"><span class="math display">\[\begin{aligned}
    P(\boldsymbol{\omega}|\rho) = \prod_{r \leq s}\frac{1}{\rho} e^{-\omega_{rs}/\rho}. \end{aligned} \tag{5}\]</span></span></p>
</div>
<p>We call&nbsp;<span class="math inline">\(\rho\)</span> the <em>density</em> parameter here since it is equal to the expected network density averaged over both the likelihood and the weight matrix prior as</p>
<div style="overflow-x:auto;overflow-y:hidden;">
<p><span class="math display">\[\begin{aligned}
    \mathbf{E}\frac{2m}{n^2} = \frac{1}{n^2} \mathbf{E} \sum_{ij} A_{ij} = \frac{1}{n^2} \sum_{ij} \mathbf{E} \omega_{b_ib_j} = \rho.\end{aligned}\]</span></p>
</div>
<p>If the number of edges&nbsp;<span class="math inline">\(m\)</span> is known, this density parameter is often set to its empirical point estimate <span class="math inline">\(\hat{\rho} = 2m/n^2\)</span>. However, in keeping with our fully Bayesian presentation we instead allow the parameter to run free with the same exponential prior used for the &nbsp;graph, <span class="math inline">\(P(\rho) = e^{-\rho}\)</span>.</p>
<p>An example of this generative process is shown in <a href="#fig-SBM-generation" class="quarto-xref">Figure&nbsp;3</a>. Although we start as in the &nbsp;model by setting the overall density&nbsp;<span class="math inline">\(\rho\)</span>, the entries of the weight matrix&nbsp;<span class="math inline">\(\boldsymbol{\omega}\)</span> can then fluctuate from this expectation, producing a network structure differentiated by group. In this example the weight matrix generates an assortative group structure, although the choice of&nbsp;<span class="math inline">\(\boldsymbol{\omega}\)</span> can specify an arbitrary pattern of connections.</p>
<div id="fig-SBM-generation" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-SBM-generation-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="../../assets/images/notes/stochastic_block_model/SBM-generation.svg" class="img-fluid figure-img" style="width:7.79217in">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-SBM-generation-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;3: Example generative process for the stochastic block model of group structure. The group each node belongs to&nbsp;<span class="math inline">\(\boldsymbol{b}\)</span>, represented by the colors, is first sampled. The overall density&nbsp;<span class="math inline">\(\rho\)</span> is then sampled and used to generate the symmetric weight matrix&nbsp;<span class="math inline">\(\omega\)</span>. In the final network&nbsp;<span class="math inline">\(\boldsymbol{A}\)</span> the density of edges between a node in group&nbsp;<span class="math inline">\(r\)</span> and a node in group&nbsp;<span class="math inline">\(s\)</span> is given by the entry&nbsp;<span class="math inline">\(\omega_{rs}\)</span>. In this example the edges within groups (colored green) are much more likely than edges between groups (red), resulting in an assortative group structure.
</figcaption>
</figure>
</div>
<p>In many applications, we will mainly be interested in inferring the group structure&nbsp;<span class="math inline">\(\boldsymbol{b}\)</span> of the network rather than the weight matrix. For this purpose we <em>marginalize</em> over the possible weight matrices&nbsp;<span class="math inline">\(\boldsymbol{\omega}\)</span> to obtain the integrated likelihood</p>
<div style="overflow-x:auto;overflow-y:hidden;">
<p><span id="eq-P-A-given-b-rho"><span class="math display">\[\begin{aligned}
    P(\boldsymbol{A}|\boldsymbol{b},\rho) &amp;= \int P(\boldsymbol{A}|\boldsymbol{\omega},\boldsymbol{b})P(\boldsymbol{\omega}|\rho) d\boldsymbol{\omega} \nonumber \\
    &amp;= \underbrace{\frac{\prod_{r &lt; s} M_{rs}! \prod_r M_{rr}!!/n_r^{m_r}}{\prod_{i&lt;j}A_{ij}!\prod_i A_{ii}!!}}_{\text{multinomial}} \&gt; \underbrace{\prod_{r &lt; s} \frac{(\rho n_r n_s)^{M_{rs}}}{(\rho n_r n_s + 1)^{M_{rs} + 1}}\prod_r \frac{(\rho n_r^2/2)^{M_{rr}/2}}{(\rho n_r^2/2 + 1)^{M_{rr}/2 + 1}}}_{\text{geometric}} \nonumber \\
    &amp;= P(\boldsymbol{A}|\boldsymbol{M},\boldsymbol{b})P(\boldsymbol{M}|\boldsymbol{n},\rho). \end{aligned} \tag{6}\]</span></span></p>
</div>
<p>This expression again factorizes into a microcanonical picture. The edge count matrix entries are distributed geometrically, while the positions of the edges between groups are distributed multinomially.</p>
<p>In terms of this integrated likelihood, we can use Bayes’ law to write the posterior distribution over potential group structures and densities</p>
<div style="overflow-x:auto;overflow-y:hidden;">
<p><span class="math display">\[\begin{aligned}
    P(\boldsymbol{b},\rho|\boldsymbol{A}) = \frac{P(\boldsymbol{A}|\boldsymbol{b},\rho)P(\boldsymbol{b})P(\rho)}{P(\boldsymbol{A})}\end{aligned}\]</span></p>
</div>
<p>This can be a complex multimodal distribution as many group structures are possible, although often only the maximum a posteriori (MAP) estimate of the community structure is reported as the best fit. For a more complete picture we can sample potential group structures from this posterior distribution using Markov Chain Monte Carlo (MCMC) methods detailed in Appendix&nbsp;<a href="#app:SBM-monte-carlo" data-reference-type="ref" data-reference="app:SBM-monte-carlo">[app:SBM-monte-carlo]</a>. These sampled partitions can then be summarized in a number of ways&nbsp;<span class="citation" data-cites="LF12 KN22">(<a href="#ref-LF12" role="doc-biblioref">Lancichinetti and Fortunato 2012</a>; <a href="#ref-KN22" role="doc-biblioref">Kirkley and Newman 2022</a>)</span>, including the consensus clustering method discussed in Appendix&nbsp;<a href="#app:consensus-clustering" data-reference-type="ref" data-reference="app:consensus-clustering">[app:consensus-clustering]</a>.</p>
<p>In <a href="#fig-SBM-posteriors" class="quarto-xref">Figure&nbsp;4</a> we show the results of this posterior sampling for the Division IA and Big Ten networks from earlier this section. We plot the posterior distributions of the number of found communities&nbsp;<span class="math inline">\(q\)</span> for each network. Since a single community&nbsp;<span class="math inline">\(q = 1\)</span> reduces to the &nbsp;random graph, its density in the posterior distribution reflects the relative evidence of the &nbsp;graph and the full SBM. The posteriors thus show that the Big Ten conference is best described by the &nbsp;model while the full Division IA network warrants the stochastic block model. From the peak of the posterior, we also observe that the SBM finds&nbsp;<span class="math inline">\(q = 10\)</span> communities in the Division IA network, again slightly less than the 12 "true" conferences. These model selections are also confirmed by the cross-validation performances of the models on the data sets reported in Table&nbsp;<a href="#tab:SBM-performances" data-reference-type="ref" data-reference="tab:SBM-performances">1</a>.</p>
<div id="fig-SBM-posteriors" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-SBM-posteriors-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="../../assets/images/notes/stochastic_block_model/SBM-posteriors.svg" class="img-fluid figure-img" style="width:4.48in">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-SBM-posteriors-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;4: Posterior distributions of the number of groups&nbsp;<span class="math inline">\(q\)</span> found by the stochastic block model within the networks of football matches within only the Big Ten conference (orange) and the entire Division IA (blue). The special case of&nbsp;<span class="math inline">\(q = 1\)</span>, for which the SBM reduced to the &nbsp;random graph is highlighted in red. We observe that while there is considerable evidence of group structure in the Division IA network, likely into 10 groups. The Big Ten conference, however, does not meaningfully have internal group structure.
</figcaption>
</figure>
</div>
<div id="tab:SBM-performances">
<table class="caption-top table">
<caption>Table of the number of communities&nbsp;<span class="math inline">\(\hat{q}\)</span> found by the SBM, the Bayesian evidence&nbsp;<span class="math inline">\(H(\boldsymbol{A})\)</span>, and posterior-predictive&nbsp;<span class="math inline">\(H(\Atest|\Atrain)\)</span> for &nbsp;and stochastic block models on the Division IA and Big Ten conference football match networks.</caption>
<thead>
<tr class="header">
<th style="text-align: left;">Data set</th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Model</td>
<td></td>
<td>SBM</td>
<td></td>
<td>SBM</td>
</tr>
<tr class="even">
<td style="text-align: left;"><span class="math inline">\(\hat{q}_{\text{MAP}}\)</span></td>
<td>N/A</td>
<td><span class="math inline">\(10\)</span></td>
<td>N/A</td>
<td><span class="math inline">\(1\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><span class="math inline">\(H(\boldsymbol{A})\)</span></td>
<td>$43</td>
<td>35.0$ $\mathbf{358</td>
<td>4.5}$ $\mathbf{17</td>
<td>1.8}$ <span class="math inline">\(172.8\)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;"><span class="math inline">\(H(\Atest|\Atrain)\)</span></td>
<td><span class="math inline">\(859.0\)</span></td>
<td><span class="math inline">\(\mathbf{710.5}\)</span></td>
<td><span class="math inline">\(\mathbf{33.89}\)</span></td>
<td><span class="math inline">\(34.03\)</span></td>
</tr>
</tbody>
</table>
</div>
<p>Although the stochastic block model thus offers a Bayesian framework for inferring and justifying community structures, the model still has certain limitations. For one, the model shares the same homogeneous distribution of degrees as the &nbsp;random model it is based upon. In order to create a model that captures both the group structure of the SBM and the degree variation of the configuration model we will need to <em>degree-correct</em> the SBM as described in Section&nbsp;<a href="#sec:SBM-degree-correction" data-reference-type="ref" data-reference="sec:SBM-degree-correction">[sec:SBM-degree-correction]</a>&nbsp;<span class="citation" data-cites="KN11a">(<a href="#ref-KN11a" role="doc-biblioref">Karrer and Newman 2011</a>)</span>. There we will observe that different networks call for various amounts of this degree correction, just as the general configuration model encompasses a spectrum of degree variation.</p>
<p>Secondly, the model suffers from a so-called <em>resolution limit</em> where the model is unable to find communities smaller than a certain size, even when they are well-separated&nbsp;<span class="citation" data-cites="FB07">(<a href="#ref-FB07" role="doc-biblioref">Fortunato and Barthélemy 2007</a>)</span>. This drawback is shared with modularity maximization, as seen by both the SBM and modularity maximization finding fewer than the true&nbsp;<span class="math inline">\(q = 12\)</span> communities of the football network. We discuss why this occurs and how to adjust the SBM to address this effect in Section&nbsp;<a href="#sec:assortative-SBM" data-reference-type="ref" data-reference="sec:assortative-SBM">[sec:assortative-SBM]</a>.</p>
<p>More fundamentally, all stochastic block models, including the novel ones presented in this thesis cannot find communities beyond a <em>detectability threshold</em> where the assortative (or disassortative) preference that defines the groups is too weak to recover among the noise&nbsp;<span class="citation" data-cites="Abbe18">(<a href="#ref-Abbe18" role="doc-biblioref">Abbe 2018</a>)</span>. In fact, this threshold is an inherent limitation of any method for identifying such groups. In Section&nbsp;<a href="#sec:reduced-mutual-information-paper" data-reference-type="ref" data-reference="sec:reduced-mutual-information-paper">[sec:reduced-mutual-information-paper]</a> we will observe how a wide variety of community detection algorithms run into the same barrier. This threshold is analogous to the phase transition of the Ising model foundational to statistical physics, a perspective we discuss more in Appendix&nbsp;<a href="#app:SBM-Ising" data-reference-type="ref" data-reference="app:SBM-Ising">[app:SBM-Ising]</a>&nbsp;<span class="citation" data-cites="Moore17">(<a href="#ref-Moore17" role="doc-biblioref">Moore 2017</a>)</span>. Although some sufficiently weak group structures can not be reliably inferred, this thesis introduces methods to uncover groups closer to this limit in Chapter&nbsp;<a href="#chp:group-structure" data-reference-type="ref" data-reference="chp:group-structure">[chp:group-structure]</a>.</p>



</section>

<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" role="doc-bibliography" id="quarto-bibliography"><h2 class="anchored quarto-appendix-heading">References</h2><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list">
<div id="ref-Abbe18" class="csl-entry" role="listitem">
Abbe, Emmanuel. 2018. <span>“Community Detection and Stochastic Block Models: Recent Developments.”</span> <em>Journal of Machine Learning Research</em> 18 (177): 1–86.
</div>
<div id="ref-Barber07" class="csl-entry" role="listitem">
Barber, Michael J. 2007. <span>“Modularity and Community Detection in Bipartite Networks.”</span> <em>Phys. Rev. E</em> 76 (December): 066102. <a href="https://doi.org/10.1103/PhysRevE.76.066102">https://doi.org/10.1103/PhysRevE.76.066102</a>.
</div>
<div id="ref-Boccaletti07" class="csl-entry" role="listitem">
Boccaletti, S., M. Ivanchenko, V. Latora, A. Pluchino, and A. Rapisarda. 2007. <span>“Detection of Complex Networks Modularity by Dynamical Clustering.”</span> <em>Pre</em> 75: 045102.
</div>
<div id="ref-FB07" class="csl-entry" role="listitem">
Fortunato, Santo, and Marc Barthélemy. 2007. <span>“Resolution Limit in Community Detection.”</span> <em>Pnas</em> 104: 36–41.
</div>
<div id="ref-GDC10" class="csl-entry" role="listitem">
Good, Benjamin H., Yves-Alexandre de Montjoye, and Aaron Clauset. 2010. <span>“Performance of Modularity Maximization in Practical Contexts.”</span> <em>Pre</em> 81: 046106.
</div>
<div id="ref-KN11a" class="csl-entry" role="listitem">
Karrer, Brian, and M. E. J. Newman. 2011. <span>“Stochastic Blockmodels and Community Structure in Networks.”</span> <em>Pre</em> 83: 016107.
</div>
<div id="ref-KN22" class="csl-entry" role="listitem">
Kirkley, Alec, and M. E. J. Newman. 2022. <span>“Representative Community Divisions of Networks.”</span> <em>Communications Physics</em> 5: 40.
</div>
<div id="ref-LF12" class="csl-entry" role="listitem">
Lancichinetti, Andrea, and Santo Fortunato. 2012. <span>“Consensus Clustering in Complex Networks.”</span> <em>Scientific Reports</em> 2 (1): 336.
</div>
<div id="ref-Moore17" class="csl-entry" role="listitem">
Moore, Cristopher. 2017. <span>“The Computer Science and Physics of Community Detection: Landscapes, Phase Transitions, and Hardness.”</span> Preprint arxiv:1702.00467.
</div>
<div id="ref-Newman06b" class="csl-entry" role="listitem">
Newman, M. E. J. 2006. <span>“Modularity and Community Structure in Networks.”</span> <em>Pnas</em> 103: 8577–82.
</div>
<div id="ref-Peixoto14a" class="csl-entry" role="listitem">
Peixoto, Tiago P. 2014. <span>“Hierarchical Block Structures and High-Resolution Model Selection in Large Networks.”</span> <em>Prx</em> 4: 011047.
</div>
<div id="ref-PK23" class="csl-entry" role="listitem">
Peixoto, Tiago P., and Alec Kirkley. 2023. <span>“Implicit Models, Latent Compression, Intrinsic Biases, and Cheap Lunches in Community Detection.”</span> <em>Physical Review. E</em> 108 (2-1): 024309–9.
</div>
<div id="ref-YL2020" class="csl-entry" role="listitem">
Yen, Tzu-Chi, and Daniel B. Larremore. 2020. <span>“Community Detection in Bipartite Networks with Stochastic Block Models.”</span> <em>Phys. Rev. E</em> 102 (September): 032309. <a href="https://doi.org/10.1103/PhysRevE.102.032309">https://doi.org/10.1103/PhysRevE.102.032309</a>.
</div>
</div></section></div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
    const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
    const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
    let newTheme = '';
    if(darkModeDefault) {
      newTheme = isAlternate ? baseTheme : alternateTheme;
    } else {
      newTheme = isAlternate ? alternateTheme : baseTheme;
    }
    const changeGiscusTheme = () => {
      // From: https://github.com/giscus/giscus/issues/336
      const sendMessage = (message) => {
        const iframe = document.querySelector('iframe.giscus-frame');
        if (!iframe) return;
        iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
      }
      sendMessage({
        setConfig: {
          theme: newTheme
        }
      });
    }
    const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
    if (isGiscussLoaded) {
      changeGiscusTheme();
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  const darkModeDefault = false;
  let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
    toggleGiscusIfUsed(toAlternate, darkModeDefault);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>