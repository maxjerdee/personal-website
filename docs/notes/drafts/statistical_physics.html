<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.555">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Max Jerdee</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<link href="../../assets/images/icon.svg" rel="icon" type="image/svg+xml">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../../site_libs/bootstrap/bootstrap-dark.min.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-SY1YC6MMLM"></script>

<script type="text/javascript">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-SY1YC6MMLM', { 'anonymize_ip': true});
</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Max Jerdee</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../research.html"> 
<span class="menu-text">Research</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../papers.html"> 
<span class="menu-text">Papers</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../demos.html"> 
<span class="menu-text">Demos</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../notes.html"> 
<span class="menu-text">Notes</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../cv.html"> 
<span class="menu-text">CV</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
          <div class="quarto-navbar-tools">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">




<p>The earlier picture of probability and inference can be usefully cast in the language of physics and energy. By leveraging this correspondence, we can import analytic and computational tools from physics to tackle statistical questions. In this section, we will define a physical model of coin flips and demonstrate its equivalence to the statistical model discussed earlier. We will then explore how this perspective motivates alternative types of models and inference techniques.</p>
<p>Physics often describes systems in terms of a&nbsp;<em>configuration space</em> of possible&nbsp;<em>states</em>. In the coin flip example, the state of the system (or "configuration") is the sequence of <span class="math inline">\(n\)</span> observed outcomes. We represent this configuration as a vector&nbsp;<span class="math inline">\(\vec{s}\)</span>, where each entry&nbsp;<span class="math inline">\(s_i = 1\)</span> indicates that flip&nbsp;<span class="math inline">\(i = 1,...,n\)</span> landed heads, and&nbsp;<span class="math inline">\(s_i = 0\)</span> represents tails. The configuration space of coin flips is thus comprised of all possible sequences of <span class="math inline">\(n\)</span> flips, forming all binary vectors of length&nbsp;<span class="math inline">\(n\)</span>.</p>
<p>This notation elicits the <em>Ising model</em> fundamental to statistical mechanics. The configurations of this model consist of atomic "spins" that reside at one of&nbsp;<span class="math inline">\(n\)</span> "sites," each in either its <em>excited state</em>&nbsp;<span class="math inline">\(s_i = 1\)</span> or <em>ground state</em>&nbsp;<span class="math inline">\(s_i = 0\)</span><a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>. We assign the excited state an <em>energy</em> of 1 and the ground state energy 0, as shown in Figure&nbsp;<a href="#fig:coin-flip-energies" data-reference-type="ref" data-reference="fig:coin-flip-energies">1</a>. The total energy of the system, referred to as the <em>Hamiltonian</em>, is then the number of excited states (or heads) <span class="math display">\[\begin{aligned}
    H(\vec{s}) = \sum_{i=1}^n \left(0 \delta_{s_i 0} + 1 \delta_{s_i 1}\right) = n_H. \label{eq:coin-flip-energy}\end{aligned}\]</span> A more general Ising model would include coupling energies between neighboring spins, but we omit them here to maintain independent coin flips. In Appendix&nbsp;<a href="#app:SBM-Ising" data-reference-type="ref" data-reference="app:SBM-Ising">[app:SBM-Ising]</a> we discuss the deep connections between the more general interacting Ising model and statistical models of network group structure.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><embed src="max_dissertation//chapters//figures//chp1/coin-flip-energies.pdf" class="img-fluid"></p>
<figcaption>Physical interpretation of coin flips. Heads ("H") have energy&nbsp;<span class="math inline">\(E = 1\)</span> while tails ("T") have energy&nbsp;<span class="math inline">\(E = 0\)</span>, so that the overall energy of the configuration&nbsp;<span class="math inline">\(\vec{s}\)</span> is equal to the number of observed heads,&nbsp;<span class="math inline">\(H(\vec{s}) = n_H\)</span>.</figcaption>
</figure>
</div>
<p>In an isolated system the energy Eq.&nbsp;<a href="#eq:coin-flip-energy" data-reference-type="eqref" data-reference="eq:coin-flip-energy">[eq:coin-flip-energy]</a> is always conserved, a fundamental law of physics. Although changes in individual spin states can occur, they must be counterbalanced by changes in other spins to maintain the "global" energy of the system. Let&nbsp;<span class="math inline">\(E\)</span> be this constant energy of the system, so that only configurations&nbsp;<span class="math inline">\(\vec{s}\)</span> where&nbsp;<span class="math inline">\(H(\vec{s}) = E\)</span> are permitted, cases with&nbsp;<span class="math inline">\(n_H = E\)</span> excited states. The number of possible system configurations (also known as <em>microstates</em>) that satisfy this condition is then the number of ways to arrange the&nbsp;<span class="math inline">\(n_H = E\)</span> excited states among the&nbsp;<span class="math inline">\(n\)</span> sites, <span class="math display">\[\begin{aligned}
    \Omega(E) = \binom{n}{E}. \label{eq:Omega-E}\end{aligned}\]</span></p>
<p>Statistical mechanics fundamentally postulates that when a system is in&nbsp;<em>equilibrium</em>, all these microstates of the same total energy are equally likely to appear. This assumption defines equilibrium statistical mechanics, the framework we adopt in this thesis. Under this postulate the probability of observing any specific configuration&nbsp;<span class="math inline">\(\vec{s}\)</span> is therefore <span class="math display">\[\begin{aligned}
    P(\vec{s}|E) = \binom{n}{E}^{-1}. \label{eq:coin-flip-P-microcanonical}\end{aligned}\]</span> This uniform distribution over all configurations of a fixed energy is known as the&nbsp;<em>microcanonical ensemble</em>. As a distribution over possible sequences of coin flips, it can also be interpreted as a&nbsp;<em>microcanonical model</em> where the continuous local probability of heads&nbsp;<span class="math inline">\(p\)</span> has been replaced by the discrete global number of heads&nbsp;<span class="math inline">\(n_H = E\)</span>.</p>
<p>Many of the statistical models we consider in this thesis are framed in this microcanonical form, where the "parameters" are globally observed quantities. While this formulation may not be well-suited for the coin flip example, where we have little reason to expect a "conservation of heads," it arises in other statistical settings where certain properties are conserved across random realizations. For instance, in a network of sports matches the total number of games played each season remains constant each year, even though the pattern of connections among teams changes. In Section&nbsp;<a href="#sec:random-graph-models" data-reference-type="ref" data-reference="sec:random-graph-models">[sec:random-graph-models]</a>, we explore further examples and observe how many network models can be written microcanonically.</p>
<p>To return to the independent coin flip model we must broaden the physical picture. Realistically most physical systems are not truly isolated but rather exchange energy with their environment in a setting known as the&nbsp;<em>canonical ensemble</em>. In physical language the original system is now a <em>subsystem</em> in equilibrium with a large <em>thermal bath</em>. Although the combined system of both the subsystem and the thermal bath must still conserve overall energy, our subsystem of interest can gain and lose energy to the thermal bath.</p>
<p>Figure&nbsp;<a href="#fig:coin-flip-ensemble" data-reference-type="ref" data-reference="fig:coin-flip-ensemble">2</a> illustrates this set up for the coin flip example. Let&nbsp;<span class="math inline">\(\tilde{\vec{s}}\)</span> represent the configuration of the thermal bath, containing <span class="math inline">\(\tilde{n}\)</span> spins and energy&nbsp;<span class="math inline">\(\tilde{E} = H(\tilde{\vec{s}})\)</span> which counts the number of excited states in the bath. Including our subsystem&nbsp;<span class="math inline">\(\vec{s}\)</span>, the full system&nbsp;<span class="math inline">\((\vec{s},\tilde{\vec{s}})\)</span> then has <span class="math inline">\(n + \tilde{n}\)</span> total spins and total energy&nbsp;<span class="math inline">\(E_T = H(\vec{s},\tilde{\vec{s}}) = E + \tilde{E}\)</span>. Since this total energy is conserved, the full system&nbsp;<span class="math inline">\((\vec{s},\vec{s}')\)</span> is uniformly distributed according to the microcanonical ensemble Eq.&nbsp;<a href="#eq:coin-flip-P-microcanonical" data-reference-type="eqref" data-reference="eq:coin-flip-P-microcanonical">[eq:coin-flip-P-microcanonical]</a> of&nbsp;<span class="math inline">\(E_T\)</span> excited states on&nbsp;<span class="math inline">\(n + \tilde{n}\)</span> sites, <span class="math display">\[\begin{aligned}
    P(\vec{s},\tilde{\vec{s}}|E_T) &amp;= \binom{n + \tilde{n}}{E_T}^{-1}. \label{eq:coin-flip-joint-microcanonical}\end{aligned}\]</span></p>
<p>Although each pair&nbsp;<span class="math inline">\((\vec{s},\vec{s}')\)</span> with total energy&nbsp;<span class="math inline">\(E_T\)</span> is equally likely, certain subsystem energies&nbsp;<span class="math inline">\(E\)</span> are more likely than others. Figure&nbsp;<a href="#fig:coin-flip-ensemble" data-reference-type="ref" data-reference="fig:coin-flip-ensemble">2</a> demonstrates this effect with two example configurations. In panel (a) the excited states ("H") are all contained within the thermal bath&nbsp;<span class="math inline">\(\tilde{\vec{s}}\)</span>, meaning that the subsystem&nbsp;<span class="math inline">\(\vec{s}\)</span> has its lowest possible energy&nbsp;<span class="math inline">\(E = 0\)</span> and the thermal bath has the full energy&nbsp;<span class="math inline">\(E_T\)</span>. In panel (b) the excited states are evenly distributed between the subsystem and the bath, and the subsystem has absorbed some energy from the bath. Across all possible configurations of the joint subsystem-bath system, imbalanced distributions like (a) are less common than balanced ones (b). Random configurations of the overall ensemble are therefore likely to be balanced. As a result, if our subsystem begins in its ground state (a) it will tend to <em>thermalize</em> into a configuration like (b) with evenly distributed excited states.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><embed src="max_dissertation//chapters//figures//chp1/coin-flip-ensemble.pdf" class="img-fluid"></p>
<figcaption>Thermalization of a subsystem (of coin flips) in contact with a thermal bath. In panel (a) all excited states ("H") are contained in the bath, an unusual configuration with overall entropy <span class="math inline">\(S(E) + \tilde{S}(\tilde{E}) = 8.77\)</span>. Panel (b) has a more typical, even arrangement of the excited states, reflected in the higher total entropy <span class="math inline">\(S(E) + \tilde{S}(\tilde{E}) = 10.82\)</span>. If the subsystem begins in the ground state (a) it will thus likely thermalize to the equilibrium (b).</figcaption>
</figure>
</div>
<p>To quantify this tendency, we can count the number of overall subsystem-bath configurations&nbsp;<span class="math inline">\((\vec{s},\tilde{\vec{s}})\)</span> with subsystem energy&nbsp;<span class="math inline">\(E\)</span>. As in Eq.&nbsp;<a href="#eq:Omega-E" data-reference-type="eqref" data-reference="eq:Omega-E">[eq:Omega-E]</a>, there are&nbsp;<span class="math inline">\(\Omega(E)\)</span> microstates of the subsystem&nbsp;<span class="math inline">\(\vec{s}\)</span> all share the same energy&nbsp;<span class="math inline">\(E\)</span>. We refer to this collection of microstates as a <em>macrostate</em> of the subsystem with energy&nbsp;<span class="math inline">\(E\)</span>. Figure&nbsp;<a href="#fig:coin-flip-entropy" data-reference-type="ref" data-reference="fig:coin-flip-entropy">3</a> illustrates this grouping of subsystem microstates into macrostates by energy. Macrostates that contain more microstates, those with higher&nbsp;<span class="math inline">\(\Omega(E)\)</span>, are naturally observed more often. We can likewise construct macrostates of the thermal bath&nbsp;<span class="math inline">\(\tilde{\vec{s}}\)</span> at energies&nbsp;<span class="math inline">\(\tilde{E}\)</span>. Considering the number of ways to arrange the <span class="math inline">\(\tilde{E}\)</span> excited states among the <span class="math inline">\(\tilde{n}\)</span> sites of the bath, there are <span class="math display">\[\begin{aligned}
    \tilde{\Omega}(\tilde{E}) = \binom{\tilde{n}}{\tilde{E}}\end{aligned}\]</span> microstates in the bath macrostate of energy&nbsp;<span class="math inline">\(\tilde{E}\)</span>. In many settings the full microstate is not observable, for instance the precise position and velocity of each molecule of a gas. In these settings the macrostate summarizes the pieces of physically relevant information that can be observed, such as the energy or pressure.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><embed src="max_dissertation//chapters//figures//chp1/coin-flip-entropy.pdf" class="img-fluid"></p>
<figcaption>Example microstates of the subsystem&nbsp;<span class="math inline">\(\vec{s}\)</span> grouped into macrostates by energy&nbsp;<span class="math inline">\(E\)</span>. Only one microstate has&nbsp;<span class="math inline">\(E = 0\)</span> while five microstates share&nbsp;<span class="math inline">\(E = 1\)</span>, meaning that the higher energy macrostate has higher entropy&nbsp;<span class="math inline">\(S(E)\)</span>. Although each microstate is equally likely, the higher entropy macrostate is more likely to be observed.</figcaption>
</figure>
</div>
<p>Since the subsystem macrostate has&nbsp;<span class="math inline">\(\Omega(E)\)</span> microstates and the bath macrostate has&nbsp;<span class="math inline">\(\tilde{\Omega}(\tilde{E})\)</span>, there are&nbsp;<span class="math inline">\(\Omega(E)\tilde{\Omega}(\tilde{E})\)</span> unique pairs&nbsp;<span class="math inline">\((\vec{s},\tilde{\vec{s}})\)</span> with subsystem energy&nbsp;<span class="math inline">\(E\)</span> and bath energy&nbsp;<span class="math inline">\(\tilde{E} = E_T - E\)</span>. Since each pair is equally likely to appear in the overall microcanonical ensemble, we thus observe subsystem energy&nbsp;<span class="math inline">\(E\)</span> with probability <span class="math display">\[\begin{aligned}
    P(E|E_T) &amp;\propto \Omega(E)\tilde{\Omega}(\tilde{E}) \nonumber \\
    &amp;\propto \Omega(E) \tilde{\Omega}(E_T - E). \end{aligned}\]</span> These macrostate multiplicities can also be written using macrostate <em>entropy</em>, defined as the logarithm<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a> <span class="math display">\[\begin{aligned}
    S(E) = \log \Omega(E) = \log \binom{n}{E}, \text{ or }\, \tilde{S}(\tilde{E}) = \log \tilde{\Omega}(\tilde{E}) = \log \binom{\tilde{n}}{\tilde{E}}. \label{eq:entropy-microcanonical-definition}\end{aligned}\]</span> The energy distribution then depends on the overall entropy&nbsp;<span class="math inline">\(S(E) + \tilde{S}(\tilde{E})\)</span> as <span class="math display">\[\begin{aligned}
    P(E|E_T) \propto e^{S(E) + \tilde{S}(\tilde{E})}. \label{eq:probability-entropy}\end{aligned}\]</span> Configurations with higher total entropy are therefore more likely to appear, as calculated in Figure&nbsp;<a href="#fig:coin-flip-ensemble" data-reference-type="ref" data-reference="fig:coin-flip-ensemble">2</a>. This tendency to observe higher entropy states is the content of the 2nd law of thermodynamics: that the entropy of the universe cannot decrease. On such large scales differences in entropy are large, and the probability Eq.&nbsp;<a href="#eq:probability-entropy" data-reference-type="eqref" data-reference="eq:probability-entropy">[eq:probability-entropy]</a> approaches a certainty, a law of physics.</p>
<p>We can similarly compute the distribution of subsystem configurations&nbsp;<span class="math inline">\(\vec{s}\)</span>, not just of its energy&nbsp;<span class="math inline">\(E\)</span>. If we fix the subsystem microstate, valid pairs&nbsp;<span class="math inline">\((\vec{s},\tilde{\vec{s}})\)</span> correspond to bath microstates&nbsp;<span class="math inline">\(\tilde{\vec{s}}\)</span> among the&nbsp;<span class="math inline">\(\tilde{\Omega}(\tilde{E})\)</span> configurations of the remaining energy. As each pair is equally probable, the subsystem is distributed as <span class="math display">\[\begin{aligned}
    P(\vec{s}|E_T) &amp;\propto \tilde{\Omega}(\tilde{E}) \nonumber \\
    &amp;\propto e^{\tilde{S}(\tilde{E})}. \label{eq:P-s-E_T}\end{aligned}\]</span> Unlike the uniform, microcanonical ensemble of the subsystem, certain configurations are now more or less likely based on the entropy of the surrounding bath.</p>
<p>In this picture the <em>canonical</em> ensemble is defined by the limit&nbsp;<span class="math inline">\(\tilde{n} \rightarrow \infty\)</span> of a large thermal bath that can effectively absorb subsystem fluctuations. We further fix the average energy&nbsp;<span class="math inline">\(p = \tilde{E}/\tilde{n}\)</span> of the thermal bath in this limit, which corresponds to a fixed density of excited states. If we Stirling approximate the binomial coefficient Eq.&nbsp;<a href="#eq:entropy-microcanonical-definition" data-reference-type="eqref" data-reference="eq:entropy-microcanonical-definition">[eq:entropy-microcanonical-definition]</a>, we find the bath’s entropy&nbsp;<span class="math inline">\(\tilde{S}(\tilde{E})\)</span> is proportional to its energy (up to a constant&nbsp;<span class="math inline">\(C\)</span>) as <span class="math display">\[\begin{aligned}
    \tilde{S}(\tilde{E}) = \beta \tilde{E} + C, \quad \beta = \log \frac{1-p}{p}. \label{eq:tilde-S-tilde-E}\end{aligned}\]</span> This constant of proportionality&nbsp;<span class="math inline">\(\beta\)</span> is known as the <em>inverse temperature</em> and relates changes in the bath energy&nbsp;<span class="math inline">\(\tilde{E}\)</span> to changes of entropy&nbsp;<span class="math inline">\(\tilde{S}\)</span> as <span class="math display">\[\begin{aligned}
    \frac{\partial \tilde{S}}{\partial \tilde{E}} = \beta = \frac{1}{T}, \label{eq:temperature-definition}\end{aligned}\]</span> aligning with the usual thermodynamic definition<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a> of the temperature&nbsp;<span class="math inline">\(T\)</span>. We will typically assume this temperature is positive and so added energy increases the entropy, although negative temperatures are possible in certain cases such as population inversion in laser physics or the coin flips when&nbsp;<span class="math inline">\(p &gt; 0.5\)</span>.</p>
<p>Comparing to Eq.&nbsp;<a href="#eq:P-s-E_T" data-reference-type="eqref" data-reference="eq:P-s-E_T">[eq:P-s-E_T]</a>, we then see that the probability of observing any given subsystem&nbsp;<span class="math inline">\(\vec{s}\)</span> in this canonical ensemble is <span class="math display">\[\begin{aligned}
    P(\vec{s}|\beta) &amp;\propto e^{\beta \tilde{E}}  \propto e^{-\beta E} \nonumber \\
    &amp;\propto e^{-\beta H(\vec{s})},\end{aligned}\]</span> where we have used that the total energy&nbsp;<span class="math inline">\(E_T = E + \tilde{E}\)</span> is conserved. In fact, by similar arguments any system&nbsp;<span class="math inline">\(\vec{s}\)</span> in thermal equilibrium with a large bath at inverse temperature&nbsp;<span class="math inline">\(\beta\)</span> follows this same&nbsp;<em>Boltzmann distribution</em> (or "Gibbs distribution")&nbsp;<span class="math inline">\(P(\vec{s}) \propto e^{-\beta H(\vec{s})}\)</span>, which may itself taken as the definition of the canonical ensemble of&nbsp;<span class="math inline">\(\vec{s}\)</span>. When&nbsp;<span class="math inline">\(T = 0\)</span>, <span class="math inline">\(\beta \rightarrow \infty\)</span>, the subsystem is stuck in its ground state with the smallest possible energy&nbsp;<span class="math inline">\(H(\vec{s})\)</span>. This aligns with the usual tendency of a physical system towards smaller energy, as a ball rolls down a hill. As the temperature increases and&nbsp;<span class="math inline">\(T \rightarrow \infty, \beta = 0\)</span>, however, the Boltzmann distribution becomes uniform and every subsystem microstate is equally likely independent of its energy.</p>
<p>At finite&nbsp;<span class="math inline">\(\beta &gt; 0\)</span> between these extremes, the typical thermal configuration may not be the ground state, even though that is the single most likely microstate. Rather, the subsystem is likely to be found in some other macrostate with higher entropy&nbsp;<span class="math inline">\(S(E)\)</span> as seen in Figure&nbsp;<a href="#fig:coin-flip-ensemble" data-reference-type="ref" data-reference="fig:coin-flip-ensemble">2</a>. Although each individual microstate of this macrostate has smaller probability than the ground state, their greater number makes their macrostate collectively more likely to be observed. This effect can be quantified by revisiting Eq.&nbsp;<a href="#eq:probability-entropy" data-reference-type="eqref" data-reference="eq:probability-entropy">[eq:probability-entropy]</a> for the distribution of energy&nbsp;<span class="math inline">\(E\)</span>. Since the large bath’s entropy is proportional to its energy we have <span class="math display">\[\begin{aligned}
    P(E|E_T) &amp;\propto e^{S(E) + \tilde{S}(\tilde{E})} \propto e^{S(E) + \beta \tilde{E}} \nonumber \\
            &amp;\propto e^{S(E) - \beta E} \propto e^{-\beta F(E)}\end{aligned}\]</span> where we have defined the <em>free energy</em> <span class="math display">\[\begin{aligned}
    F(E) = E - T S(E).\end{aligned}\]</span> The most likely energy&nbsp;<span class="math inline">\(E\)</span> to be observed is therefore the minimum of this free energy. Depending on the temperature&nbsp;<span class="math inline">\(T\)</span>, this may no longer be the ground state energy due to the influence of the entropy&nbsp;<span class="math inline">\(S(E)\)</span>.</p>
<p>To complete the description of the canonical ensemble, we normalize the Boltzmann distribution as <span class="math display">\[\begin{aligned}
    P(\vec{s}|\beta) = \frac{1}{Z(\beta)}e^{-\beta H(\vec{s})}, \quad Z(\beta) = \sum_{\vec{s}} e^{-\beta H(\vec{s})} \label{eq:boltzmann-distribution}\end{aligned}\]</span> with the partition function&nbsp;<span class="math inline">\(Z(\beta)\)</span>, a quantity which tells us much about the system in its own right. For example, its logarithmic derivative <span class="math display">\[\begin{aligned}
    - \partial_\beta \log Z(\beta) &amp;= - \frac{1}{Z(\beta)} \partial_\beta \sum_{\vec{s}} e^{-\beta H(\vec{s})} \nonumber \\
    &amp;= \frac{1}{Z(\beta)} \sum_{\vec{s}} H(\vec{s}) e^{-\beta H(\vec{s})} \nonumber \\
    &amp;= \langle E \rangle \label{eq:average-energy-partition-function}\end{aligned}\]</span> yields the average energy&nbsp;<span class="math inline">\(\langle E \rangle\)</span> under the Boltzmann distribution.</p>
<p>If we normalize the Boltzmann distribution of our coin flip system with the partition function&nbsp;<span class="math inline">\(Z(\beta) = (1-p)^{-n}\)</span>, we obtain <span class="math display">\[\begin{aligned}
    P(\vec{s}|p) &amp;= \frac{1}{Z(\beta)} e^{-\beta H(\vec{s})} \nonumber \\
    &amp;= \frac{1}{(1 - p)^{-n}} e^{-\log \left(\frac{1-p}{p}\right) \, n_H} \nonumber \\
    &amp;= p^{n_H}(1-p)^{n - n_H} \label{eq:coin-flips-thermal}\end{aligned}\]</span> which we recognize as the model likelihood Eq.&nbsp;<a href="#eq:coin-flip-likelihood" data-reference-type="eqref" data-reference="eq:coin-flip-likelihood">[eq:coin-flip-likelihood]</a> for biased coin flips with probability&nbsp;<span class="math inline">\(p\)</span>. In this correspondence, we can check that the average energy relation Eq.&nbsp;<a href="#eq:average-energy-partition-function" data-reference-type="eqref" data-reference="eq:average-energy-partition-function">[eq:average-energy-partition-function]</a> of the physical system indeed recovers the expected number of heads <span class="math display">\[\begin{aligned}
    \langle E \rangle = -\partial_\beta \log Z(\beta) = p n.\end{aligned}\]</span> Unlike the microcanonical ensemble, the number of observed heads&nbsp;<span class="math inline">\(n_H = E\)</span> can now thermally fluctuate about this expectation via exchange with its surroundings in a manner that exactly reproduces independent coin flips.</p>
<p>This example motivates us to draw a broader analogy between statistics and physics. In Eq.&nbsp;<a href="#eq:coin-flips-thermal" data-reference-type="eqref" data-reference="eq:coin-flips-thermal">[eq:coin-flips-thermal]</a> we described a physical system that reproduces the biased coin flip likelihood, the same distribution of flip outcomes given a fixed parameter&nbsp;<span class="math inline">\(p\)</span>. Often, however, we are interested in the reverse inference problem of understanding the space of likely parameter values&nbsp;<span class="math inline">\(p\)</span> given a particular observation. Suppose we have a generic model&nbsp;<span class="math inline">\(P(\vec{x}|\vec{\theta})\)</span> of data&nbsp;<span class="math inline">\(\vec{x}\)</span> with parameters&nbsp;<span class="math inline">\(\vec{\theta}\)</span>. As discussed in Appendix&nbsp;<a href="#app:statistical-inference" data-reference-type="ref" data-reference="app:statistical-inference">[app:statistical-inference]</a>, the posterior distribution of parameters inferred from data&nbsp;<span class="math inline">\(\vec{x}\)</span> is by Bayes’ law <span class="math display">\[\begin{aligned}
    P(\vec{\theta}|\vec{x}) &amp;= \frac{P(\vec{x}|\vec{\theta})P(\vec{\theta})}{P(\vec{x})}.\end{aligned}\]</span></p>
<p>For a fixed observation&nbsp;<span class="math inline">\(\vec{x}\)</span>, the corresponding physical system is defined by the Hamiltonian <span class="math display">\[\begin{aligned}
    H(\vec{\theta}) = -\log P(\vec{x}|\vec{\theta}) \label{eq:energy-posterior-relation}\end{aligned}\]</span> over the configuration space of possible parameters&nbsp;<span class="math inline">\(\vec{\theta}\)</span>. If we assume a uniform prior&nbsp;<span class="math inline">\(P(\vec{\theta}) = 1\)</span>, the posterior distribution over parameters is proportional to the Boltzmann distribution of this system at unit temperature&nbsp;<span class="math inline">\(\beta = 1\)</span> <span class="math display">\[\begin{aligned}
    P(\vec{\theta}|\vec{x}) \propto P(\vec{x}|\vec{\theta}) \propto e^{-H(\vec{\theta})}.\end{aligned}\]</span> In fact, if we normalize the Boltzmann distribution as <span class="math display">\[\begin{aligned}
    P(\vec{\theta}|\vec{x}) = \frac{1}{Z(1)} e^{-H(\vec{\theta})},\end{aligned}\]</span> the partition function&nbsp;<span class="math inline">\(Z(1)\)</span> is equal to the Bayesian evidence <span class="math display">\[\begin{aligned}
    Z(1) = \sum_{\vec{\theta}} e^{-H(\vec{\theta})} = \sum_{\vec{\theta}} P(\vec{x}|\vec{\theta}) P(\vec{\theta}) = P(\vec{x}).\end{aligned}\]</span> Through this correspondence we can explore the posterior distribution of any Bayesian model by simulating the behavior of the analogous physical system.</p>
<p>This equivalence highlights a subtle philosophical difference between the physical perspective and the common statistical view of these problems. In statistics, particularly in frequentist treatments, we often consider and report the single best-fit parameter of a model that maximizes&nbsp;<span class="math inline">\(P(\vec{\theta}|\vec{x})\)</span>. Physically, this is akin to identifying the ground state configuration with the lowest energy&nbsp;<span class="math inline">\(H(\vec{\theta})\)</span>.</p>
<p>Yet in physics, we are usually more interested in the typical behavior of the system across the entire thermal ensemble rather than the nature of the single most probable microstate. As shown in Figure&nbsp;<a href="#fig:coin-flip-ensemble" data-reference-type="ref" data-reference="fig:coin-flip-ensemble">2</a>, there may be many other less likely yet more entropic configurations that dominate the overall distribution when taken together. In common glass, for example, although the ground state would be an ordered crystalline structure, thermal fluctuations make the typical configuration amorphous, giving the material its signature uniform transparency. Keeping with this perspective, in this work we will consider the full posterior distribution when possible to give a comprehensive picture of system behavior.</p>
<p>For this purpose we employ Markov Chain Monte Carlo (MCMC) methods, a common technique to simulate generic physical systems and so to sample from generic probability distributions. This strategy performs a weighted random walk over configuration space, analogous to thermalization and dispersion in a real system. Returning to our coin flip example, we can consider how in Figure&nbsp;<a href="#fig:coin-flip-ensemble" data-reference-type="ref" data-reference="fig:coin-flip-ensemble">2</a> the subsystem dynamically evolves. If our subsystem&nbsp;<span class="math inline">\(\vec{s}\)</span> begins in a the low entropy ground state (a), through the jostling of the coins the system will naturally tend towards a typical, high entropy configuration (b). Yet physically this transition is not instantaneous. For instance, gas molecules kinetically bump into each other and gradually disperse throughout their enclosure. We use Markov chain methods to simulate coin flip thermalization as a process that occurs one coin flip at a time.</p>
<p>A Markov chain walks through configuration space in discrete increments of time. At each step the Markov chain <em>transitions</em> from one state at time&nbsp;<span class="math inline">\(t\)</span> to another state at slightly later time&nbsp;<span class="math inline">\(t + \Delta t\)</span>. This is a random walk, where a move from state&nbsp;<span class="math inline">\(\vec{s}\)</span> to&nbsp;<span class="math inline">\(\vec{s}'\)</span> is made with probability <span class="math inline">\(P(\vec{s} \rightarrow \vec{s}')\)</span>. Under mild conditions on the transition probabilities, this Markov chain will converge to some equilibrium distribution&nbsp;<span class="math inline">\(P(\vec{s})\)</span>. If the states of the Markov chain are distributed according the equilibrium&nbsp;<span class="math inline">\(P(\vec{s})\)</span>, the final&nbsp;<span class="math inline">\(\vec{s}'\)</span> after the chain move&nbsp;<span class="math inline">\(\vec{s} \rightarrow \vec{s}'\)</span> will by definition share the equilibrium distribution <span class="math display">\[\begin{aligned}
    P(\vec{s}') = \sum_{\vec{s}}P(\vec{s})P(\vec{s} \rightarrow \vec{s}'). \label{eq:MCMC-stability}\end{aligned}\]</span> We are then left with the problem of constructing a Markov chain which has the particular equilibrium distribution&nbsp;<span class="math inline">\(P(\vec{s})\)</span> we are interested in.</p>
<p>A simple and ubiquitous way to establish such a chain is known as the <em>Metropolis-Hastings algorithm</em>. Each step in this Markov chain consists of two parts. First, a move to a new state is <em>proposed</em> given the current state. Second, that move is either <em>accepted</em> and the chain moves to the new state, or it is <em>rejected</em> and the chain remains at its current state. If we propose moves with transition probabilities&nbsp;<span class="math inline">\(P_{\text{prop}}(\vec{s} \rightarrow \vec{s}')\)</span>, we accept each proposal with probability <span class="math display">\[\begin{aligned}
    P_{\text{acc}}(\vec{s} \rightarrow \vec{s}') = \text{min}\left(1, \frac{P(\vec{s}')P_{\text{prop}}(\vec{s}' \rightarrow \vec{s})}{P(\vec{s})P_{\text{prop}}(\vec{s} \rightarrow \vec{s}')}\right).\end{aligned}\]</span> We will often use symmetric proposals where&nbsp;<span class="math inline">\(P_{\text{prop}}(\vec{s} \rightarrow \vec{s}') = P_{\text{prop}}(\vec{s}' \rightarrow \vec{s})\)</span>, for which this acceptance probability simplifies to <span class="math display">\[\begin{aligned}
    P_{\text{acc}}(\vec{s} \rightarrow \vec{s}') = \text{min}\left(1, \frac{P(\vec{s}')}{P(\vec{s})}\right) = \text{min}\left(1, e^{\beta(H(\vec{s}) - H(\vec{s}'))}\right).\end{aligned}\]</span> In terms of the system energy&nbsp;<span class="math inline">\(H(\vec{s})\)</span>, we see that the algorithm will always accept changes that decrease the energy, and occasionally moves that increase it, an emulation of how the real system evolves.</p>
<p>From this two-step process the overall Markov chain transition probabilities are then distinguished by if they increase or decrease the probability as <span class="math display">\[\begin{aligned}
    P(\vec{s} \rightarrow \vec{s}') = \begin{cases}
        P_{\text{prop}}(\vec{s} \rightarrow \vec{s}') &amp; P(\vec{s}') \geq P(\vec{s}), \vec{s} \not= \vec{s}'\\
        P_{\text{prop}}(\vec{s} \rightarrow \vec{s}')\frac{P(\vec{s}')}{P(\vec{s})} &amp; P(\vec{s}') &lt; P(\vec{s})\\
        P_{\text{prop}}(\vec{s} \rightarrow \vec{s}) + \sum_{\vec{s}' &lt; \vec{s}} P_{\text{prop}}(\vec{s} \rightarrow \vec{s}') \left[1 - \frac{P(\vec{s}')}{P(\vec{s})}\right]&amp; \vec{s}' = \vec{s}
    \end{cases}\end{aligned}\]</span> where sum in the case&nbsp;<span class="math inline">\(\vec{s}' = \vec{s}\)</span> accounts for all the rejected proposals to states&nbsp;<span class="math inline">\(\vec{s}'\)</span> with probability&nbsp;<span class="math inline">\(P(\vec{s}') &lt; P(\vec{s})\)</span>. Summing over these cases, now of states&nbsp;<span class="math inline">\(\vec{s}\)</span> that can produce a state&nbsp;<span class="math inline">\(\vec{s}'\)</span>, we can check the stability condition Eq.&nbsp;<a href="#eq:MCMC-stability" data-reference-type="eqref" data-reference="eq:MCMC-stability">[eq:MCMC-stability]</a> as <span class="math display">\[\begin{aligned}
    \sum_{\vec{s}} P(\vec{s})P(\vec{s} \rightarrow \vec{s}') &amp;= \sum_{\vec{s} &lt; \vec{s}'} P(\vec{s}) P_{\text{prop}}(\vec{s} \rightarrow \vec{s}') + \sum_{\vec{s} &gt; \vec{s}'} P(\vec{s}) \frac{P(\vec{s}')}{P(\vec{s})}P_{\text{prop}}(\vec{s} \rightarrow \vec{s}') \nonumber\\
    &amp;+ P(\vec{s}')P_{\text{prop}}(\vec{s}' \rightarrow \vec{s}') + P(\vec{s}') \sum_{\vec{s} &gt; \vec{s}'} P_{\text{prop}}(\vec{s}' \rightarrow \vec{s})\left[1 - \frac{P(\vec{s})}{P(\vec{s}')}\right] \nonumber\\
    &amp;= P(\vec{s}')\sum_{\vec{s}} P_{\text{prop}}(\vec{s} \rightarrow \vec{s}') = P(\vec{s}').\end{aligned}\]</span></p>
<p>Therefore the desired distribution is a fixed point of the Metropolis-Hastings algorithm, regardless of the choice of proposals&nbsp;<span class="math inline">\(P_{\text{prop}}(\vec{s} \rightarrow \vec{s}')\)</span>. However, being a Markov chain, there is still a clear correlation between subsequent steps in the random walk. Only after a typical number of Markov chain known as the <em>mixing time</em> are the samples meaningfully independent. Therefore to efficiently obtain independent samples from the distribution, to for example compute expectations, the mixing time should be as small as possible. The form these proposals take can considerably impact the mixing time, and clever choices are often needed to make Monte Carlo methods tractable.</p>
<p>A common choice of proposal for discrete settings like this is to consider <em>single site flips</em> where we choose a random site&nbsp;<span class="math inline">\(i\)</span> and flip it from heads to tails, <span class="math inline">\(s_i = 1 \mapsto 0\)</span> or vice versa. An advantage to this local change is that the resulting chance in the probability (or energy) is small and therefore likely to be accepted. If a entirely new global configuration is drawn uniformly at random, it likely has a much lower probability (or higher energy) than the current sample, and so will likely be rejected and waste an iteration of the algorithm.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><embed src="max_dissertation//chapters//figures//chp1/MCMC-coin-flip.pdf" class="img-fluid"></p>
<figcaption>Trajectory of the Metropolis-Hastings MCMC algorithm to thermalize a system of 100 coin flips. The system begins in the ground state where&nbsp;<span class="math inline">\(n_H = 0\)</span>. The average value&nbsp;<span class="math inline">\(n_H = 40\)</span> is highlighted. Once the Markov chain has thermalized, the samples are indicative of this average value.</figcaption>
</figure>
</div>
<p>If we apply this to our simple coin flipping example, Figure&nbsp;<a href="#fig:MCMC-coin-flip" data-reference-type="ref" data-reference="fig:MCMC-coin-flip">4</a> shows how the number of flips changes over the course of the Metropolis-Hastings algorithm. We can observe that although the system starts in a configuration not particularly representative of the equilibrium distribution, after many iterations the Markov chain thermalizes the state. Although this is a fairly simple distribution, one we could sample directly, the flexibility of MCMC allows us apply it to far more complex distributions to draw inferences. In doing this, however, we must be careful to ensure that the Markov chain has adequately converged. If samples are interpreted too early in the algorithm, results will be skewed by the initial state, as in the initial samples of Figure&nbsp;<a href="#fig:MCMC-coin-flip" data-reference-type="ref" data-reference="fig:MCMC-coin-flip">4</a>.</p>
<p>These Monte Carlo methods are very powerful, and are the workhorse of the statistical inferences made in this thesis. In order to apply these methods to their fullest, we can further augment the Metropolis-Hastings algorithm by performing <em>parallel tempering</em> to reduce the mixing time of the Markov chains and <em>thermodynamic integration</em> to compute the Bayesian evidence in a manner analogous to how such methods are used to compute the physical free energy.</p>




<div id="quarto-appendix" class="default"><section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><h2 class="anchored quarto-appendix-heading">Footnotes</h2>

<ol>
<li id="fn1"><p>The two values of an Ising model spin are typically denoted as&nbsp;<span class="math inline">\(s_i = 1\)</span> for the "up" state and&nbsp;<span class="math inline">\(s_i = -1\)</span> for the "down" state, in line with the magnetic dipole moments they physically represent, although the choice of basis does not alter the underlying physics.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>More generally defined as&nbsp;<span class="math inline">\(S = k_B \log \Omega\)</span> where&nbsp;<span class="math inline">\(k_B \approx 1.38 \text{ J}/\text{K}\)</span> is the Boltzmann constant. The units of this constant are due to the thermodynamic relation Eq.&nbsp;<a href="#eq:temperature-definition" data-reference-type="eqref" data-reference="eq:temperature-definition">[eq:temperature-definition]</a>.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p>This definition ensures that if two thermal baths at temperatures&nbsp;<span class="math inline">\(T_1 &gt; T_2 &gt; 0\)</span> are brought into contact energy will flow from the higher temperature bath to the lower temperature bath to increase the overall entropy, in keeping with the 2nd law of thermodynamics.<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section></div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
    const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
    const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
    let newTheme = '';
    if(darkModeDefault) {
      newTheme = isAlternate ? baseTheme : alternateTheme;
    } else {
      newTheme = isAlternate ? alternateTheme : baseTheme;
    }
    const changeGiscusTheme = () => {
      // From: https://github.com/giscus/giscus/issues/336
      const sendMessage = (message) => {
        const iframe = document.querySelector('iframe.giscus-frame');
        if (!iframe) return;
        iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
      }
      sendMessage({
        setConfig: {
          theme: newTheme
        }
      });
    }
    const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
    if (isGiscussLoaded) {
      changeGiscusTheme();
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  const darkModeDefault = false;
  let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
    toggleGiscusIfUsed(toAlternate, darkModeDefault);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>